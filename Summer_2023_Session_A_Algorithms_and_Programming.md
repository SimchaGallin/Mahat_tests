<div dir="rtl">


    חלק א׳       
#### ענו על ארבע מבין השאלות 6-1 (ערך כל שאלה – 12 נקודות) 

# 
שאלה 1
מספר שלם חיובי נקרא "מספר מושלם" אם הוא מתחלק בסכום ספרותיו.
לדוגמה:
מספר 12 הוא מספר מושלם, מספר 24 הוא מספר מושלם, מספר 25 אינו מספר מושלם. כתבו קטע תוכנית להדפסת כל המספרים המושלמים מ- 1 עד 1,000.



```python
def sum_of_num(num):
    # משתנה שמחזיק את סכום הספרות
    con = 0
    # עוברים על כל ספרה במספר
    for i in str(num):
        # מוסיפים את הספרה לסכום
        con += int(i)
    # מחזירים את סכום הספרות
    return con

def perfect_number():
    # משתנה שמחזיק את מספר המספרים המושלמים שמצאנו
    con = 0
    # עוברים על כל המספרים בטווח 1 עד 1000
    for i in range(1,1001):
        # בודקים אם המספר מתחלק בסכום הספרות שלו
        if i % sum_of_num(i) == 0:
            # אם כן, מגדילים את המונה של המספרים המושלמים ב-1
            con += 1
            # מדפיסים את המספר המושלם
            print(i, end=" ")

perfect_number()
```

                                שאלה 2       
מחרוזת שמייצגת "מספר נייד תקין" היא מחרוזת העונה לשלושה תנאים: • שלושת התווים ראשונים הם קידומת (050, 051, 052, 053, 054, 055, 056, 057, 058). • התו הרביעי הוא מקף (-).
• שבעת התווים הבאים הם ספרות. לדוגמה: המחרוזת 050-1230567 היא מספר נייד תקין. כתבו קטע תוכנית הקולטת מחרוזות עד שתקלט מחרוזת שהיא מספר נייד תקין. יש להדפיס מספר המחרוזות שנקלטו.




```python
def valid_phone():
    # משתנה שמחזיק את מספר הניסיונות שלא הצליחו
    filed_chance = 0
    while True:
        # רשימת הקידומות התקניות
        prefix_number = '050', '051', '052', '053', '054', '055', '056', '057', '058'
        # בקשה מהמשתמש להזין מספר טלפון
        phone_number = input("Please Enter your Phone :")
        # הקידומת של המספר
        prefix = phone_number[:3]
        # הסימן שאמור להיות אחרי הקידומת
        score = '-'
        # שארית המספר לאחר הקידומת והסימן
        rest_of_phone_number = phone_number[4:]
        # בדיקה אם הקידומת נמצאת ברשימת הקידומות, הסימן הוא מקף ושארית המספר מורכבת מספרות בלבד
        if prefix in prefix_number and phone_number[3] == score and rest_of_phone_number.isnumeric():
            # אם המספר תקני, מחזירים את מספר הניסיונות שלא הצליחו ואת הערך True
            return f" After {filed_chance} \n the number is:{True}"
        else:
            # אם המספר לא תקני, מוסיפים 1 למשתנה שמחזיק את מספר הניסיונות שלא הצליחו
            filed_chance += 1

valid_phone()
```

                                שאלה 3  

 רשימה של מספרים שלמים נקרת "רשימה מסודרת" אם כל הערכים הזוגיים (אם יש כאלה) נמצאים בתחילת הרשימה וכל הערכים האי-זוגיים (אם יש כאלה) נמצאים אחריהם, בסוף הרשימה. לדוגמה: הרשימות הבאות הן רשימות "מסודרות":
                  lst1 = [6, 24, 12, 8, 44, 3, 7]
                  lst2 = [6, 24, 12, 8, 16, 22]
(6 נק') א. כתבו פעולה המקבלת רשימה של מספרים שלמים arr. הפעולה תחזיר ערך True, אם הרשימה "מסודרת" ולא, הפעולה תחזיר ערך False.
כותרת הפעולה:
is_ordered(arr)
(6 נק') ב. כתבו פעולה המקבלת שלושה פרמטרים מטיפוס מספר שלם: y ,x ,size.
הפעולה צריכה ליצור רשימה מסודרת של מספרים שלמים בגודל size המלאה במספרים אקראיים בין x ל- y (כולל). כותרת הפעולה:
                         build_ordered(size, x, y)
אפשר להניח ש- 0>size וגם x<y.

```python


def ordered_list(arr):
    # משתנה שמחזיק את האינדקס של המספר האי-זוגי הראשון ברשימה
    index = 0
    # עוברים על כל האינדקסים ברשימה
    for i in range(len(arr)):
        # בודקים אם המספר באינדקס הנוכחי הוא מספר אי-זוגי
        if arr[i] % 2 == 1:
            # אם כן, שמים את האינדקס שלו במשתנה index ומפסיקים את הלולאה
            index = i
            break
    else:
        # אם לא מצאנו מספר אי-זוגי, זה אומר שכל המספרים ברשימה הם זוגיים ולכן הרשימה מסודרת
        return True

    # עוברים על האינדקסים שלא בדקנו עדיין
    for j in range(index,len(arr)):
        # בודקים אם המספר באינדקס הנוכחי הוא מספר זוגי
        if arr[j] % 2 == 0:
            # אם כן, זה אומר שיש לנו מספר זוגי אחרי מספר אי-זוגי ולכן הרשימה לא מסודרת
            return False
    else:
        # אם לא מצאנו מספר זוגי אחרי מספר אי-זוגי, זה אומר שהרשימה מסודרת
        return True

# חלק ב'
import random

def oerdarr(x, y, size):
    # רשימה של מספרים זוגיים
    equal = []
    # רשימה של מספרים אי-זוגיים
    odd = []
    # עוברים על כל מספר מ-0 עד size
    for i in range(size):
        # מייצרים מספר אקראי בין x ל-y
        num = random.randint(x, y)
        # בודקים אם המספר הוא זוגי
        if num % 2 == 0:
            # אם כן, מוסיפים אותו לרשימת המספרים הזוגיים
            equal.append(num)
        else:
            # אם לא, מוסיפים אותו לרשימת המספרים האי-זוגיים
            odd.append(num)
    # מחזירים את הרשימה שמתחילה במספרים הזוגיים וממשיכה במספרים האי-זוגיים
    return equal + odd

print(ordered_list([6, 24, 12, 8, 44, 3, 7]))
print(oerdarr(1, 10, 10))

```

                                שאלה 4
 מייצגת נקודת זמן לפי מספר שעות ומספר דקות.המחלקה Time

    
    class Time:
         def __init__(self, hour, minutes):
              self.hour = hour
              self.minutes = minutes


א. כתבו במחלקה  פעולה המקבלת הפניה לאובייקט מטיפוס  ״זמן״ ומחזירה את מספר הדקות שעברו בין הזמן המיוצג על-ידי האובייקט שמפעיל את הפעולה (self ) לזמן המיוצג באמצעות  other. 

אפשר להניח ש- self לפני other.

 ב. חברת משלוחים מבטיחה ללקוחותיה שכל משלוח יגיע למען לא מאוחר משלוש שעות (180 דקות) מהרגע שהתקבל בחברה. 

כתבו קטע תוכנית לבדיקה. הקטע צריך לקלוט עבור כל אחד מ- 100 משלוחים את זמני קבלתו בחברה ומסירתו לידי הלקוח. עבור כל משלוח ייקלטו ארבעה מספרים שלמים. לדוגמה: עבור משלוח שהתקבל בחברה ב- 10:50 ונמסר ללקוח ב- 12:20 יש לקלוט ארבעה מספרים: 10, 50, 12, 20. קטע התוכנית יבדוק אם חברת המשלוחים קיימה את ההבטחה וידפיס הודעה מתאימה. עליכם להיעזר בפעולה שכתבתם בסעיף א'. 


```python

class Time:
    # פונקציית האתחול של המחלקה, מקבלת שעה ודקות ומאתחלת את האובייקט
    def __init__(self, hour, minutes):
        self.hour = hour
        self.minutes = minutes

    # פונקציה שמחשבת את ההפרש בין שני זמנים
    def difference(self,other):
        # מחשבים את הזמן של האובייקט השני בדקות
        other_time = (other.hour * 60) + other.minutes
        # מחשבים את הזמן של האובייקט הנוכחי בדקות
        self_time = (self.hour * 60) + self.minutes
        # מחזירים את ההפרש בין הזמנים בדקות
        return abs(other_time - self_time)


# לולאה שרצה פעם אחת (במקור השאלה הרצה- 100 פעמים)

for i in range(1):
    # מבקשים מהמשתמש להזין שעה ודקות לזמן הראשון
    self_hour = int(input("לזמן הראשון -> אנא הזן שעה (בפורמט 24 שעות):"))
    self_min = int(input("לזמן הראשון -> אנא הזן דקות:"))
    # מבקשים מהמשתמש להזין שעה ודקות לזמן השני
    outer_hour = int(input("לזמן השני -> אנא הזן שעה (בפורמט 24 שעות):"))
    other_min = int(input("לזמן השני -> אנא הזן דקות:"))

    # יוצרים שני אובייקטים של זמן
    first = Time(self_hour,self_min)
    second = Time(outer_hour,other_min)

    # בודקים אם ההפרש בין הזמנים גדול מ-180 דקות
    if Time.difference(first, second) > 180:
        print(f"ההפרש הוא {Time.difference(first, second)} דקות. \nההפרש גדול מ-180 דקות, זהו משלוח לא חוקי.")
    else:
        print(f"ההפרש הוא {Time.difference(first, second)} דקות. \nזהו משלוח חוקי.")
```


                                שאלה 5

נתונה הפעולה what המקבלת רשימה של מספרים שלמים באורך זוגי
```python
def what(a):
    length = len(a)
    for i in range(2,length-1,2):
        if a[i]<a[i-2]:
            return False
        i+=1
        if a[i]>a[i-2]:
            return False
    return True
```


נתונה רשימה מספרים שלמים a:

  ` a = [1, 25, 3, 8, 10, 4, 20, 5]`


(5 נק') א. עקבו בעזרת טבלת מעקב אחרי ביצוע הפעולה ורשמו מה תחזיר הפעולה.


טבלת מעקב היא כלי שמשמש לבדיקת תקינות וניפוי שגיאות בקוד. היא מאפשרת לעקוב אחר הערכים של המשתנים והביטויים בכל שלב של הרצת הקוד, ולוודא שהם תואמים את הציפיות.

לאחר מעקב : הפעולה החזירה את הערך False 


(2 נק') ב. תנו דוגמה לרשימה בגודל עשרה ערכים שעבורו הפעולה `what` תחזיר ערך `True`.

`a = [1, 10, 3, 8, 5, 6 , 7, 2, 9,0]`
הרשימה הזו תחזיר ערך `True`


(2 נק') ג. מה מבצעת הפעולה what באופן כללי?


`הפעולה what  בודקת האם אברי המערך a  אותו היא מקבלת , עולים עבור האינדקסים הזוגיים ויורדים באינדקסים האי זוגיים.`


(3 נק') ד. נתונה רשימה b של מספרים שלמים. ידוע שתוצאת הזימון what(b) היא True.


כתבו פעולה יעילה ככל האפשר, המחזירה את הערך הגדול ביותר ברשימה b. מהי סיבוכיות הפעולה שכתבתם?

```python
def big_value(b):
    
    if b[1] > b[len(b)-2]:
        print(b[1])
    else:
        print(b[len(b) -2])

```

סיבוכיות הפעולה היא O(1) כיוון שהפעולה מבצעת פעולות קבועות ולא תלויות באורך הרשימה.



                                שאלה 6




```python

```

                                שאלה 7 




```python

```

                                שאלה 8 
(5 נק') א׳

כתבו פעולה המקבלת שתי רשימות של מספרים שלמים ובודקת אם הן הפוכות. אם כן – הפעולה תחזיר ערך `True`, ולא – תחזיר ערך `False`.




```python
def revers(lst1,lst2):
    """
    פונקציה שמקבלת שתי רשימות של מספרים שלמים ובודקת אם הן הפוכות.
    אם הן הפוכות, הפונקציה מחזירה True, אחרת היא מחזירה False.

    :param lst1: רשימה של מספרים שלמים
    :param lst2: רשימה של מספרים שלמים
    :return: True אם הרשימות הן הפוכות, False אחרת
    """
    # עוברים על כל האינדקסים ברשימה הראשונה
    for i in range(len(lst1)):
        # בודקים אם האיבר באינדקס הנוכחי ברשימה הראשונה שונה מהאיבר באינדקס המתאים ברשימה השנייה
        # האינדקס המתאים ברשימה השנייה הוא האינדקס ההפוך (-1-i)
        if lst1[i] != lst2[-1-i]:
            # אם מצאנו איבר ששונה, מחזירים False ומפסיקים את הלולאה
            return False
    # אם לא מצאנו איבר ששונה, מחזירים True
    return True
```

לדוגמא :
```python
a = [1, 25, 3, 8, 10, 4, 20, 5]
b = [5, 20, 4, 10, 8, 3, 25, 1]

print(revers(a, b))  # יחזיר True
```


(1 נק') ב.
מהי הסיבוכיות של הפעולה שכתבתם? הסבירו את תשובתכם:

`הסיבוכיות של הפעולה היא O(n), כאשר n הוא אורך הרשימה. הסיבה לכך היא שאנו עוברים על כל איבר ברשימה בדיוק פעם אחת. במהלך כל איטרציה, אנו בודקים אם האיבר ברשימה הראשונה שונה מהאיבר המתאים ברשימה השנייה, פעולה שמתבצעת בזמן קבוע. לכן, הסיבוכיות הכוללת של הפעולה היא פרופורציונלית לאורך הרשימה, כלומר O(n).`


                                שאלה 9



נתונה מחלקה Digits המתארת ספרות של מספר שלם וחיובי. למחלקה Digits תכונה אחת בלבד arr_digits – רשימה בת עשרה ערכים מטיפוס מספר שלם, המייצגת את מספר הפעמים שבו כל ספרה בין 0‐9 מופיעה במספר.
![צילום מסך 2024-01-29 ב-22.32.07.png](..%2F..%2F..%2F..%2Fvar%2Ffolders%2Fq5%2Ftfbw2fcs7hbdgc_gcjs0x8040000gn%2FT%2FTemporaryItems%2FNSIRD_screencaptureui_MkYjZJ%2F%D7%A6%D7%99%D7%9C%D7%95%D7%9D%20%D7%9E%D7%A1%D7%9A%202024-01-29%20%D7%91-22.32.07.png)

(4 נק') א. כתבו במחלקה Digits פעולה בונה (constructor) המקבלת כפרמטר מספר שלם חיובי
כלשהו ומאתחלת את התכונה arr_digits בהתאם (כלומר הרשימה תכיל את מספר הפעמים שכל ספרה מופיעה בו).
```python
class Digits:
    def __init__(self,num):
        """
        פונקציית האתחול של המחלקה. מקבלת מספר ומאתחלת את האובייקט עם רשימה של ספרות המספר.
        :param num: המספר שעליו נבנה האובייקט
        """
        # מאתחל רשימה של 9 אפסים
        arr_digits = [0,0,0,0,0,0,0,0,0]
        # עובר על כל ספרה במספר
        for i in str(num):
            # מוסיף 1 למקום המתאים ברשימה
            arr_digits[int(i)] += 1

        # שומר את הרשימה במשתנה של האובייקט
        self.num = arr_digits
```
**לדוגמא עבור הקריאה הבאה לפונקציה:**
```python
print(Digits(123).num)
```
**יתקבל הפלט:**
```python
[0, 1, 1, 1, 0, 0, 0, 0, 0, 0]
```
מכוון שבמספר 123 יש ספרה 1 אחת, ספרה 2 אחת וספרה 3 אחת.

________________________________________

(3 נק') ב. כתבו במחלקה Digits פעולה equals המקבלת הפניה לעצם אחר מטיפוס Digit.
הפעולה תחזיר ערך True אם שני העצמים זהים, ולא – הפעולה תחזיר ערך False.

```python

    def equals(self,other_Digit):
        """
        פונקציה שמקבלת הפניה לאובייקט אחר מטיפוס Digits ובודקת אם שני האובייקטים זהים.
        אם הם זהים, הפונקציה מחזירה True, אחרת היא מחזירה False.
        :param other_Digit: האובייקט השני שנבדוק את האובייקט הנוכחי איתו
        :return: True אם האובייקטים זהים, False אחרת
        """
        return self.num == other_Digit.num
```
(3 נק') ג. נתון קטע הבא:
```python
num1 = int(input("first number:"))
num2 = int(input("second number:"))
dg1=Digits(num1)
dg2=Digits(num2)
if dg1.equals(dg2):
    print("the numbers are equal")
else:
    print("the number are not equal")
```
האם הפעולה מדפיסה תוצאה נכונה עבור כל זוג מספרים שלמים וחיובים num1 ו-num2? הסבירו את תשובתכם.

`במידה והשאלה מתייחסת למספר עצמו התשובה היא שלילית, מכיוון שייתכנו זוג מספרים שאינם שווים בספרותיהם כגון : 123 ו 312 שאינם שווים בערכם ועדין הפונקציה תחזיר ״המספרים שווים״ וזאת מכוון שהפונקציה quals   בודקת אם הarr digit  שלהם שווה ולא המספר עצמו. `
________________________________________
(5 נק') ד. כתבו במחלקה Digits פעולה compare_to המקבלת כפרמטר הפניה לעצם other מטיפוס Digits.
- הפעולה תחזיר 1 אם מספר המיוצג על ידי העצם המפעיל את הפעולה (this) גדול ממספר המיוצג על ידי העצם שהתקבל כפרמטר (other).
- הפעולה תחזיר 2 אם המספר המיוצג על ידי העצם המפעיל את הפעולה (this) קטן מהמספר המיוצג על ידי העצם שהתקבל כפרמטר (other).
- אם אין אפשרות לתשובה חד משמעית, הפעולה תחזיר 0.


```python
def compare_to(self,other_Digit):
    """
    משווה בין שני אובייקטים.
    :param other_Digit: האובייקט להשוואה
    :return: 0 אם האובייקטים שווים, 1 אם האובייקט הנוכחי גדול, 2 אם האובייקט האחר גדול
    """
    # מאתחל משתנים לסכום, מונה ואינדקס של האובייקט הנוכחי והאחר
    sum_self = 0
    sum_other = 0
    counter_self = 0
    counter_other = 0
    index_self = None
    index_other = None

    # עובר על כל האיברים ברשימה של האובייקט הנוכחי
    for s in range(len(self.num)):
        # אם האיבר לא שווה לאפס, מוסיף 1 למונה ושומר את האינדקס
        if self.num[s] > 0:
            counter_self += 1
            index_self = s
        # מוסיף את האיבר לסכום
        sum_self += self.num[s]

    # עובר על כל האיברים ברשימה של האובייקט האחר
    for o in range(len(other_Digit.num)):
        # אם האיבר לא שווה לאפס, מוסיף 1 למונה ושומר את האינדקס
        if other_Digit.num[o] > 0:
            counter_other += 1
            index_other = o
        # מוסיף את האיבר לסכום
        sum_other += other_Digit.num[o]

    # אם הסכומים שווים
    if sum_self == sum_other:
        # אם המונים שווים
        if counter_other == counter_self:
            # אם האינדקסים שווים
            if index_self == index_other:
                return 0
            # אם האינדקס של האובייקט הנוכחי גדול יותר
            elif index_self > index_other:
                return 1
            # אם האינדקס של האובייקט האחר גדול יותר
            elif index_other > index_self:
                return 2

        # אם אחד המונים גדול מ-1
        if counter_other or counter_self > 1:
            return 0
        # אם האינדקס של האובייקט הנוכחי גדול יותר
        elif index_self > index_other:
            return 1
        # אם האינדקס של האובייקט האחר גדול יותר
        else:
            return 2

    # אם הסכום של האובייקט הנוכחי גדול יותר
    elif sum_self > sum_other:
        return 1

    # אם הסכום של האובייקט האחר גדול יותר
    else:
        return 2
```




                                שאלה 10


</div>