                        # חלק א'
# ענו על ארבע מבין השאלות 6-1 (ערך כל שאלה – 12 נקודות).

"""
                    (12 נק') שאלה 1
כתבו קטע קוד שקולט מספרים שלמים עד שייקלט מספר תלת ספרתי.
יש להדפיס את מספר הגדול ביותר שנקלט ואת מספר הקטן שנקלט.
"""


# הגדרת משתנים למספר המקסימלי והמינימלי
max_val = None
min_val = None

# התחלת לולאה אינסופית
while True:
    # קליטת מספר מהמשתמש
    user_input = int(input("אנא הכנס מספר:"))

    # בדיקה אם המספר הוא מספר תלת-ספרתי
    if 99 < abs(user_input) <= 999:
        break

    # בדיקה אם זו הפעם הראשונה שמספר מתקבל
    if max_val is None and min_val is None:
        max_val = user_input
        min_val = user_input

    # בדיקה אם המספר החדש הוא המספר הגדול ביותר שהתקבל עד כה
    if user_input > max_val:
        max_val = user_input

    # בדיקה אם המספר החדש הוא המספר הקטן ביותר שהתקבל עד כה
    if user_input < min_val:
        min_val = user_input

# הדפסת המספר הגדול ביותר והקטן ביותר שהתקבלו
print(f"המספר הגדול ביותר שהתקבל: {max_val}\nהמספר הקטן ביותר שהתקבל: {min_val}")



"""
                שאלה 2

(6 נק') א. מחרוזת "תקינה" היא מחרוזת העונה לשני תנאים הבאים:
• אורך המחרוזת אי-זוגי.
• תו ראשון זהה לתו אמצעי וזהה לתו האחרון.
לדוגמה: המחרוזת "AbbAc1A" היא "מחרוזת תקינה".

כתבו פעולה המקבלת מחרוזת ובודקת אם היא "מחרוזת תקינה".
אם כן – הפעולה תחזיר ערך True , ולא – הפעולה תחזיר ערך False.

כותרת הפעולה:is_valid(s)"""


# פונקציה שבודקת אם מחרוזת היא "תקינה"
def is_valid(s):
    # הגדרת משתנים שיכילו את התווים: הראשון, האמצעי והאחרון במחרוזת

    first_char,mid_char, last_char = s[0], s[len(s) // 2], s[len(s) -1]
    # בדיקה אם אורך המחרוזת הוא אי-זוגי ובנוסף שהתו הראשון, האמצעי והאחרון זהים
    if len(s) % 2 != 0 and first_char == mid_char == last_char:
        return True

    return False



"""
(6 נק') ב׳
כתבו קטע קוד הקולט 23 מחרוזות.
הקטע יחשב וידפיס מספר "מחרוזות תקינות" ומספר מחרוזות לא תקינות.
יש להשתמש בפעולה שכתבתם בסעיף א'."""

# משתנה שמחזיק את מספר המחרוזות התקניות
validated_strings_count = 0

# לולאה שרצה 23 פעמים
for i in range(23):
    # קליטת מחרוזת מהמשתמש
    user_input = input("אנא הכנס מחרוזת:")

    # בדיקה אם המחרוזת היא תקנית
    if is_valid(user_input):
        # אם המחרוזת תקנית, מוסיפים 1 למשתנה valid
        validated_strings_count += 1

# הדפסת מספר המחרוזות התקניות והלא תקניות
print(f"מספר המחרוזות התקניות: {validated_strings_count}\nמספר המחרוזות הלא תקניות: {23 - validated_strings_count}")




"""
(12  נק') שאלה 3.                          
רשימה של מספרים שלמים נקראת "רשימה מאוזנת" אם היא עונה על תנאים הבאים:
• כמות האיברים החיוביים שווה לכמות האיברים השליליים.
• הרשימה לא כולל אפסים. כתבו פעולה המקבלת רשימה של מספרים שלמים.
אם הרשימה מאוזנת יש להדפיס אותה מתחילתה ועד סופה בשורה אחת,
ולא – יש להדפיס אותה בסדר הפוך (מסוף הרשימה להתחלה).

"""

def is_balanced(arr):
    # משתנה שמחזיק את מספר האיברים החיוביים ברשימה
    positive_counter = 0

    # בדיקה אם מספר האיברים ברשימה הוא מספר זוגי
    if len(arr) % 2 == 1:
        return False

    # עוברים על כל איבר ברשימה
    for i in arr:
        # אם האיבר הוא אפס, הרשימה אינה מאוזנת
        if i == 0:
            return False

        # אם האיבר הוא מספר חיובי, מוסיפים 1 למונה
        elif i > 0:
            positive_counter += 1

    # בדיקה אם מספר האיברים החיוביים שווה למספר האיברים השליליים
    return len(arr) - positive_counter == positive_counter



"""
שאלה 4                                             
חברת "פרחי הארץ" מגדלת פרחים ושולחת אותם למכירה לחוץ לארץ.
נתונה מחלקה FlowerPackage המייצגת משלוח פרחים המיועד לשליחה לחו"ל.
למחלקה יש את התכונות הבאות:
• type – סוג הפרח, מטיפוס מחרוזת. •
num – מספר פרחים במשלוח, מטיפוס מספר שלם. 
• time – מספר שעות שניתן להחזיק את הפרחים ללא מים, מטיפוס מספר שלם.
• price – מחיר פרח בודד, מטיפוס מספר ממשי.


במחלקה הוגדרה פעולה בונה (בנאי) המקבל פרמטרים לכל התכונות.
(4 נק') א. כתבו פעולה בונה המקבלת סוג פרח ומחיר. הפעולה מייצרת משלוח סטנדרטי של 2,000 פרחים.
זמן סטנדרטי שאפשר להחזיק את הפרחים ללא מים – 12 שעות.
"""

class FlowerPackage:
    # פעולה בונה שמקבלת את סוג הפרח, מספר הפרחים, זמן האחסון ללא מים ומחיר הפרח
    def __init__(self, type, num, time, price):
        self.type = type  # סוג הפרח
        self.num = num  # מספר הפרחים
        self.time = time  # זמן האחסון ללא מים
        self.price = price  # מחיר הפרח

    # פעולה שמייצרת משלוח סטנדרטי של 2000 פרחים עם זמן אחסון של 12 שעות
    def delivery(self,flower_type, flower_price):

        # יצירת משלוח חדש עם הפרמטרים הנתונים והגדרות סטנדרטיות למספר הפרחים וזמן האחסון
        new_delivery = FlowerPackage(flower_type,num =2000, time=12, price=flower_price)
        return new_delivery  # מחזירה את המשלוח החדש




"""

                            (8 נק') ב.
עקב בעיות לוגיסטיות, חברת התעופה מציעה מסלול טיסה ארוך יותר.
חלק ממשלוחים לא ישרדו טיסה ארוכה ואז אי אפשר יהיה למכור את הפרחים.
"פרחי הארץ" תדרוש מחברת התעופה פיצוי על ההפסד הכספי.
כתבו פעולה חיצונית המקבלת רשימה הפניות לעצמים מסוג FlowerPackage בשם arr ואורך הטיסה flyTime.
הפעולה תדפיס פרטי המשלוחים שלא יהיו תקינים.
הפעולה גם תחשב ותדפיס סכום ש"פרחי הארץ" הפסידה. כותרת הפעולה:
                    compensation(arr, flyTime)
                    
הנחה: כל איבר ברישמה מכיל הפניה לעצם מסוג FlowerPackage ואין איברים שערכם שווה ל- null."""

def compensation(arr, flyTime):
    """
    מחשב את הפיצוי עבור כל הפרחים שזמן ה- flyTime גדול מזמן חיי הפרחים
    הפיצוי מחושב כך: מספר הפרחים כפול המחיר.
    """
    compensation = 0
    for flower in arr:
        if flyTime > flower.time:
            compensation += flower.num * flower.price

    return compensation








if __name__ =="__main__":
    print(is_valid("AbbAc1A"))  # פונקציה עבור שאלה 2(א).
    print(is_balanced([1,2,5,-5,-1,-2]))  #פונקציה עבור שאלה 3.

    # מימוש של שאלה 4(א)
    # יצירת מופע של המחלקה FlowerPackage
    flower_package = FlowerPackage.delivery("Rose", 5.5)

    # הדפסת המאפיינים של המשלוח
    print(f"Type: {flower_package.type}")
    print(f"Number of flowers: {flower_package.num}")
    print(f"Storage time without water: {flower_package.time}")
    print(f"Price per flower: {flower_package.price}")



    # מימוש של פונקציה :שאלה 4(ד)

    flower1 = FlowerPackage("ROSE", 10, 14, 5.0)
    flower2 = FlowerPackage("LILY", 10, 10, 6.5)
    flower3 = FlowerPackage("TULIP", 10, 13, 4.7)
    flower4 = FlowerPackage("DAISY", 10, 9, 7.0)

    arr = [flower1, flower2, flower3, flower4]

    print(compensation(arr, 12))


    pass